module.exports = function (opt) {
  def_opt = {};
  if(!opt.server){
    def_opt.server = require('http').createServer();
  }

  var io = require('socket.io')(opt.server || def_opt.server, opt.socket_io);

  if(opt.session){
    var sharedsession = require("express-socket.io-session");
    io.use(sharedsession(opt.session));
  }

  var callbacks = {
    binding: [],
    login: undefined,
    logout: undefined,
    query: [],
    middleware: []
  };

  var paths = [];

  io.on("connection", function(socket) {

    if(!socket.handshake.session.data) socket.handshake.session.data={};

    socket.on("login", function(login_data, client_callback) {
      if(callbacks.login){
        var response = callbacks.login(login_data, socket.handshake.session, function (response) {
          if (!response.error){
            socket.handshake.session.user = {
              id: response.user.id,
              capabilities: response.user.capabilities
            };
            socket.handshake.session.save();
            client_callback(response.client_params);
          }else client_callback(response);
        });
      } else client_callback({error: "login_system_is_not_configured"});
    });

    socket.on("logout", function(data, client_callback) {
      if(callbacks.logout){
        var response = callbacks.logout(socket.handshake.session, function (response) {
          if (!response.error){
            delete socket.handshake.session.user;
            socket.handshake.session.save();
            client_callback(response.client_params);
          } else client_callback(response);
        });
      } else client_callback({error: "login_system_is_not_configured"});
    });

    socket.on("check", function (option, client_callback) {
      switch (option) {
        case 'login':
          client_callback(!!socket.handshake.session.user);
          break;
      }
    })

    socket.on('bind', function (path, callback) {
      for (var p in paths) {
        if (paths.hasOwnProperty(p) && paths[p].path==path) {
          var provide = function () {
            var cl_exist = false;
            for (var s in paths[p].clients) {
              if (paths[p].clients.hasOwnProperty(s) && paths[p].clients[s].id==socket.id) {
                cl_exist = true;
                break;
              }
            }
            if(!cl_exist) paths[p].clients.push(socket);

            if(paths[p].provider) paths[p].provider(function (value) {
              if(value) callback([{op: "replace", path: path, value: value}]);
              else callback(undefined);
            }, socket.handshake.session);
            else callback(undefined);
          }
          if(paths[p].scope == "global") provide();
          else if (typeof paths[p].scope == "object" && socket.handshake.session.user) {
            var priv_exist = false;
            for (var c in paths[p].scope) {
              if (paths[p].scope.hasOwnProperty(c) && socket.handshake.session.user.capabilities.indexOf(paths[p].scope[c])>-1) {
                provide();
                priv_exist=true;
              }
            }
            if(!priv_exist) callback(undefined);
          }else if (paths[p].scope == "user" && socket.handshake.session.user) {
            provide();
          }
        }
      }
    });

    socket.on('unbind', function (path) {
      for (var p in paths) {
        if (paths.hasOwnProperty(p) && paths[p].path==path) {
          for (var s in paths[p].clients) {
            if (paths[p].clients.hasOwnProperty(s) && paths[p].clients[s].id==socket.id) {
              delete paths[p].clients[s];
            }
          }
        }
      }
    });

    socket.on('patch', function (patch) {
      apply_patch(patch, socket.handshake.session.user);
    });

    socket.on("disconnect", function() {
      for (var p in paths) {
        if (paths.hasOwnProperty(p)) {
          for (var s in paths[p].clients) {
            if (paths[p].clients.hasOwnProperty(s) && paths[p].clients[s].id==socket.id) {
              delete paths[p].clients[s];
            }
          }
        }
      }
    });

    socket.on('query', function (params, client_callback) {
      run_query(params.url, params.params, socket.handshake.session, client_callback);
    });

  });

  if(def_opt.server) def_opt.server.listen(opt.port || process.env.PORT || 80);

  return {
    bind: function (path, scope, provider, patch_processor) {
      var exist = false;
      for (var p in paths) {
        if (paths.hasOwnProperty(p) && paths[p].path==path) {
          paths[p].scope = scope;
          paths[p].provider = provider;
          paths[p].patch_processor = patch_processor;
          exist = true;
        }
      }
      if(!exist) paths.push({
        path: path,
        scope: scope,
        provider: provider,
        patch_processor: patch_processor,
        clients: []
      });
    },
    patch: function (patch, user) {
      apply_patch(patch, user);
    },
    on: function (event, callback) {
      switch (event) {
        case "login":
          callbacks.login = callback;
          break;
        case "logout":
          callbacks.logout = callback;
          break;
        default:
        throw new unknown_event();
      }
    },
    off: function (event) {
      switch (event) {
        case "login":
          callbacks.login = undefined;
          break;
        case "logout":
          callbacks.logout = undefined;
          break;
        default:
        throw new unknown_event();
      }
    },
    query: function (url, callback) {
      var exist = false;
      for (var c in callbacks.query) {
        if (callbacks.query.hasOwnProperty(c) && callbacks.query[c].url==url) {
          callbacks.query[c].callback = callback;
          exist = true;
        }
      }
      if(!exist) callbacks.query.push({url: url, callback: callback});
    },
    redirect: function (url, params, session, callback) {
      run_query(url, params, session, callback);
    },
    middleware: function (url, callback) {
      callbacks.middleware.push({
        url: url,
        callback: callback
      });
    }
  }

  function apply_patch(patch, user) {
    for (var p in patch) {
      if (patch.hasOwnProperty(p)) {
        for (var path in paths) {
          if (paths.hasOwnProperty(path) && patch[p].path.indexOf(paths[path].path)==0 || (patch[p].op=="move" && patch[p].from.indexOf(paths[path].path)==0)) {
            paths[path].patch_processor(patch[p]);
            for (var c in paths[path].clients) {
              if (paths[path].clients.hasOwnProperty(c) && ((paths[path].scope != "user") || (paths[path].scope == "user" && paths[path].clients[c].handshake.session.user.id==user.id))) {
                paths[path].clients[c].emit("patch", [patch[p]]);
              }
            }
          }
        }
      }
    }
  }

  function run_query(url, params, session, callback) {
    run_middlewares(url, params, session, function (url, params, session, callback) {
      for (var c in callbacks.query) {
        if (callbacks.query.hasOwnProperty(c) && callbacks.query[c].url==url) {
          callbacks.query[c].callback(params, session, callback);
        }
      }
    }, callback);
  }

  function run_middlewares(url, params, session, next, client_callback) {
    var i = -1;
    var run_middleware = function () {
      i++;
      if (callbacks.middleware[i] != undefined) {
        if (!callbacks.middleware[i].url || url.indexOf(callbacks.middleware[i].url)==0) callbacks.middleware[i].callback(url.substring(url.indexOf(callbacks.middleware[i].url), url.length - callbacks.middleware[i].url.length), params, session, run_middleware, client_callback);
        else run_middleware();
      } else next(url, params, session, client_callback);
    }
    run_middleware();
  }

  function unknown_event(){
    this.message = "Unknown event";
    this.toString = function () {
      return this.message;
    };
  }

  function xPath_get(data, path) {
    var keys = path.split("/");
    var val=data;
    keys.forEach(function (k) {
      if(k!=""){
        if(val.hasOwnProperty(k)) val=val[k];
        else return undefined;
      }
    });
    return val;
  }

  function xPath_create(data, path) {
    var keys = path.split("/");
    var val=data;
    keys.forEach(function (k) {
      if(k!=""){
        if(!val.hasOwnProperty(k)) val[k]={};
        val=val[k];
      }
    });
    return val;
  }

  function xPath_delete(data, path) {
    var keys = path.split("/");
    var val=data;
    keys.forEach(function (k) {
      if(k!=""){
        if(val.hasOwnProperty(k)) val=val[k];
        else return undefined;
      }
    });
    delete val;
  }
}
