var iosync = (function(){

  var _socket = io.connect("ws://" + location.host);
  var _data = {}; // container of ll syncronized data
  var _observers = [];
  var _ignore = []; // we used this var to prevent observe loopback

  jsonpatch.observe(_data, function (patch) {
    // detecting ptach type
    var client_patches = [];
    var server_patches = [];
    patch.forEach(function (p) {
      var ign = false;
      for (var i = 0; i < _ignore.length; i++) {
        if(!jsonpatch.compare(p,_ignore[i]).length){ // patch is from server so prevent loopback to server
          _ignore.splice(i,1); // thanks _ignore, now we don't need that patch anymore
          ign = true;
          server_patches.push(p); // store the ptach to notify client watchers later
          break; // search done
        }
      }
      if(!ign) client_patches.push(p); // if patch don't exists in server patches so it's a client patch
    });
    if(client_patches.length){
      _socket.emit("patch", client_patches); // emit patches to server
    }

    // trigger observers
    _observers.forEach(function (o) {
      var patches = [];
      client_patches.forEach(function (p) {
        if((p.path && p.path.indexOf(o.path))==0 || (p.op=="move" && p.from.indexOf(o.path)==0)){ // check if observer is watching this path
          p.source = "client"; // define patch source
          patches.push(p);
        }
      });
      server_patches.forEach(function (p) {
        if((p.path && p.path.indexOf(o.path))==0 || (p.op=="move" && p.from.indexOf(o.path)==0)){
          p.source = "server";
          patches.push(p);
        }
      });
      if(patches.length) {
        o.observer(xPath_get(o.path), patches); // trigger the observer
      }
    });

  });

  _socket.on('patch', function (patch) { // yeah! we have new patches from server
    Array.prototype.push.apply(_ignore, patch); // save patches into _ignore to prevent jsonpatch.observe send them back to server
    jsonpatch.apply(_data, patch); // apply ptches
  });

  return{
    bind: function (path, observer) {
      path = (path.charAt(0)!="/"?"/":"") + path; // add the first '/' if it dosn't exists
      if(typeof observer === "function") _observers.push({ // observer is optional, because we provide "reference binding"
        path: path, // what it will observe
        observer: observer // callback function
      });

      // create an empty var temporary until the server send us the content
      console.log(xPath_get(path));
      if(xPath_get(path) != undefined){
        var add = {op:"add", path: path, value: {}};
        _ignore.push(add);
        jsonpatch.apply(_data, [add]);
      }

      _socket.emit("bind", path, function (patch) { // notify server to provide us lastest value, and upcoming updates
        if(patch){
          Array.prototype.push.apply(_ignore, patch); // save patches into _ignore to prevent jsonpatch.observe send them back to server
          jsonpatch.apply(_data, patch); // apply patches
        }
      });
      return xPath_get(path); // return it also for "reference binding"
    },
    unbind: function (path) {
      _socket.emit("unbind", path); // notify server to stop sending us updates about that var
      var patch = {"op": "remove", "path": path};
      _ignore.push(patch); // prevent sending remove patch to server
      jsonpatch.apply(_data, [patch]); // delete that path locally
    },
    patch: function (path, value) {
      jsonpatch.apply(_data, [{op: "replace", path: path, value: value}]);
    },
    login: function (params, callback) {
      _socket.emit('login', params, callback);
    },
    logout: function (callback) {
      _socket.emit('logout', '', callback);
    },
    check: function (option, callback) {
      _socket.emit('check', option, callback);
    },
    query: function (url, params, callback) {
      _socket.emit('query', {url: url, params: params}, callback);
    }
  }

  function xPath_get(path) {
    var keys = path.split("/");
    var val=_data;
    for (var k in keys) {
      if(keys.hasOwnProperty(k) && keys[k]!=""){ // escape empty keys
        if(val.hasOwnProperty(keys[k])) val=val[keys[k]]; // okay, jump to that key
        else return undefined; // oups, key does not exists
      }
    }
    return val; // path exists so return it's value
  }

  function xPath_create(path) {
    var keys = path.split("/");
    var val=_data;
    for (var k in keys) {
      if(keys.hasOwnProperty(k) && keys[k]!=""){ // escape empty keys
        if(!val.hasOwnProperty(keys[k])) val[keys[k]]={}; // oups, key does not exists, so create it
        val=val[keys[k]]; // okay, jump to that key
      }
    }
    return val; // return created value
  }

  function xPath_delete(path) {
    var keys = path.split("/");
    var val=_data;
    for (var k in keys) {
      if(keys.hasOwnProperty(k) && keys[k]!=""){ // escape empty keys
        if(val.hasOwnProperty(keys[k])) val=val[keys[k]]; // okay, jump to that key
        else return undefined; // oups, key does not exists
      }
    }
    delete val; // path exists so delete it
  }

  function deepCompare () {
    var i, l, leftChain, rightChain;

    function compare2Objects (x, y) {
      var p;

      // remember that NaN === NaN returns false
      // and isNaN(undefined) returns true
      if (isNaN(x) && isNaN(y) && typeof x === 'number' && typeof y === 'number') {
           return true;
      }

      // Compare primitives and functions.
      // Check if both arguments link to the same object.
      // Especially useful on step when comparing prototypes
      if (x === y) {
          return true;
      }

      // Works in case when functions are created in constructor.
      // Comparing dates is a common scenario. Another built-ins?
      // We can even handle functions passed across iframes
      if ((typeof x === 'function' && typeof y === 'function') ||
         (x instanceof Date && y instanceof Date) ||
         (x instanceof RegExp && y instanceof RegExp) ||
         (x instanceof String && y instanceof String) ||
         (x instanceof Number && y instanceof Number)) {
          return x.toString() === y.toString();
      }

      // At last checking prototypes as good a we can
      if (!(x instanceof Object && y instanceof Object)) {
          return false;
      }

      if (x.isPrototypeOf(y) || y.isPrototypeOf(x)) {
          return false;
      }

      if (x.constructor !== y.constructor) {
          return false;
      }

      if (x.prototype !== y.prototype) {
          return false;
      }

      // Check for infinitive linking loops
      if (leftChain.indexOf(x) > -1 || rightChain.indexOf(y) > -1) {
           return false;
      }

      // Quick checking of one object beeing a subset of another.
      // todo: cache the structure of arguments[0] for performance
      for (p in y) {
          if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
              return false;
          }
          else if (typeof y[p] !== typeof x[p]) {
              return false;
          }
      }

      for (p in x) {
          if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
              return false;
          }
          else if (typeof y[p] !== typeof x[p]) {
              return false;
          }

          switch (typeof (x[p])) {
              case 'object':
              case 'function':

                  leftChain.push(x);
                  rightChain.push(y);

                  if (!compare2Objects (x[p], y[p])) {
                      return false;
                  }

                  leftChain.pop();
                  rightChain.pop();
                  break;

              default:
                  if (x[p] !== y[p]) {
                      return false;
                  }
                  break;
          }
      }

      return true;
    }

    if (arguments.length < 1) {
      return true; //Die silently? Don't know how to handle such case, please help...
      // throw "Need two or more arguments to compare";
    }

    for (i = 1, l = arguments.length; i < l; i++) {

        leftChain = []; //Todo: this can be cached
        rightChain = [];

        if (!compare2Objects(arguments[0], arguments[i])) {
            return false;
        }
    }

    return true;
  }

})();
